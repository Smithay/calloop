<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Run async code - A Guide to Calloop</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="ch00-00-where-to-start.html">Where to start</a></li><li class="chapter-item expanded "><a href="ch01-00-how-an-event-loop-works.html"><strong aria-hidden="true">1.</strong> How an event loop works</a></li><li class="chapter-item expanded "><a href="ch02-00-event-sources.html"><strong aria-hidden="true">2.</strong> Using event sources</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-generic.html"><strong aria-hidden="true">2.1.</strong> Monitoring a file descriptor</a></li><li class="chapter-item expanded "><a href="ch02-02-timers.html"><strong aria-hidden="true">2.2.</strong> Timers</a></li><li class="chapter-item expanded "><a href="ch02-03-ping.html"><strong aria-hidden="true">2.3.</strong> Ping</a></li><li class="chapter-item expanded "><a href="ch02-04-channels.html"><strong aria-hidden="true">2.4.</strong> Channels</a></li><li class="chapter-item expanded "><a href="ch02-05-signals.html"><strong aria-hidden="true">2.5.</strong> Unix Signals</a></li><li class="chapter-item expanded "><a href="ch02-06-errors.html"><strong aria-hidden="true">2.6.</strong> Error handling</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-async-await.html"><strong aria-hidden="true">3.</strong> I need async/await!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-run-async-code.html" class="active"><strong aria-hidden="true">3.1.</strong> Run async code</a></li><li class="chapter-item expanded "><a href="ch03-02-async-io-types.html"><strong aria-hidden="true">3.2.</strong> Async IO types</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-a-full-example-zeromq.html"><strong aria-hidden="true">4.</strong> A full example: ZeroMQ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-composition.html"><strong aria-hidden="true">4.1.</strong> Composition</a></li><li class="chapter-item expanded "><a href="ch04-02-creating-our-source-part-1-our-types.html"><strong aria-hidden="true">4.2.</strong> Creating our source, part I: our types</a></li><li class="chapter-item expanded "><a href="ch04-03-creating-our-source-part-2-setup-methods.html"><strong aria-hidden="true">4.3.</strong> Creating our source, part II: setup methods</a></li><li class="chapter-item expanded "><a href="ch04-04-creating-our-source-part-3-processing-events-almost.html"><strong aria-hidden="true">4.4.</strong> Creating our source, part III: processing events (almost)</a></li><li class="chapter-item expanded "><a href="ch04-05-creating-our-source-part-4-processing-events-really.html"><strong aria-hidden="true">4.5.</strong> Creating our source, part IV: processing events (really)</a></li><li class="chapter-item expanded "><a href="ch04-06-the-full-zeromq-event-source-code.html"><strong aria-hidden="true">4.6.</strong> The full ZeroMQ event source code</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">A Guide to Calloop</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/detly/calloop/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="run-async-code"><a class="header" href="#run-async-code">Run async code</a></h1>
<blockquote>
<h2 id="enable-the-executor-feature"><a class="header" href="#enable-the-executor-feature">Enable the <code>executor</code> feature!</a></h2>
<p>To use <code>calloop::futures</code> you need to enable the <code>executor</code> feature in your <code>Cargo.toml</code> like so:</p>
<pre><code class="language-toml">[dependencies.calloop]
features = [ &quot;executor&quot; ]
version = ...
</code></pre>
</blockquote>
<p>Let's say you have some async code that looks like this:</p>
<pre><code class="language-rust noplayground">sender.send(&quot;Hello,&quot;).await.ok();
receiver.next().await.map(|m| println!(&quot;Received: {}&quot;, m));
sender.send(&quot;world!&quot;).await.ok();
receiver.next().await.map(|m| println!(&quot;Received: {}&quot;, m));
&quot;So long!&quot;
</code></pre>
<p>...and a corresponding block that receives and sends to this one. I will call one of these blocks &quot;friendly&quot; and the other one &quot;aloof&quot;.</p>
<p>To run async code in Calloop, you use the components in <a href="api/calloop/futures/"><code>calloop::futures</code></a>. First, obtain both an executor and a scheduler with <a href="api/calloop/futures/fn.executor.html"><code>calloop::futures::executor()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(clippy::uninlined_format_args)]
</span><span class="boring">
</span><span class="boring">use calloop::EventLoop;
</span><span class="boring">
</span><span class="boring">// futures = &quot;0.3&quot;
</span><span class="boring">use futures::sink::SinkExt;
</span><span class="boring">use futures::stream::StreamExt;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; std::io::Result&lt;()&gt; {
</span>    let (exec, sched) = calloop::futures::executor()?;
<span class="boring">
</span><span class="boring">    let mut event_loop = EventLoop::try_new()?;
</span><span class="boring">    let handle = event_loop.handle();
</span><span class="boring">
</span><span class="boring">    handle
</span><span class="boring">        .insert_source(exec, |evt, _metadata, _shared| {
</span><span class="boring">            // Print the value of the async block ie. the return value.
</span><span class="boring">            println!(&quot;Async block ended with: {}&quot;, evt);
</span><span class="boring">        })
</span><span class="boring">        .map_err(|e| e.error)?;
</span><span class="boring">
</span><span class="boring">    // Let's create two channels for our async blocks below. The blocks will
</span><span class="boring">    // exchange messages via these channels.
</span><span class="boring">    let (mut sender_friendly, mut receiver_friendly) = futures::channel::mpsc::unbounded();
</span><span class="boring">    let (mut sender_aloof, mut receiver_aloof) = futures::channel::mpsc::unbounded();
</span><span class="boring">
</span><span class="boring">    // Our toy async code.
</span><span class="boring">    let async_friendly_task = async move {
</span><span class="boring">        sender_friendly.send(&quot;Hello,&quot;).await.ok();
</span><span class="boring">        if let Some(msg) = receiver_aloof.next().await {
</span><span class="boring">            println!(&quot;Aloof said: {}&quot;, msg);
</span><span class="boring">        }
</span><span class="boring">        sender_friendly.send(&quot;world!&quot;).await.ok();
</span><span class="boring">        if let Some(msg) = receiver_aloof.next().await {
</span><span class="boring">            println!(&quot;Aloof said: {}&quot;, msg);
</span><span class="boring">        }
</span><span class="boring">        &quot;Bye!&quot;
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let async_aloof_task = async move {
</span><span class="boring">        if let Some(msg) = receiver_friendly.next().await {
</span><span class="boring">            println!(&quot;Friendly said: {}&quot;, msg);
</span><span class="boring">        }
</span><span class="boring">        sender_aloof.send(&quot;Oh,&quot;).await.ok();
</span><span class="boring">        if let Some(msg) = receiver_friendly.next().await {
</span><span class="boring">            println!(&quot;Friendly said: {}&quot;, msg);
</span><span class="boring">        }
</span><span class="boring">        sender_aloof.send(&quot;it's you.&quot;).await.ok();
</span><span class="boring">        &quot;Regards.&quot;
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    // Schedule the async block to be run in the event loop.
</span><span class="boring">    sched.schedule(async_friendly_task).unwrap();
</span><span class="boring">    sched.schedule(async_aloof_task).unwrap();
</span><span class="boring">
</span><span class="boring">    // Run the event loop.
</span><span class="boring">    println!(&quot;Starting event loop. Use Ctrl-C to exit.&quot;);
</span><span class="boring">    event_loop.run(None, &amp;mut (), |_| {})?;
</span><span class="boring">    println!(&quot;Event loop ended.&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>The <em>executor</em>, the part that <em>executes</em> the future, goes in the event loop:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(clippy::uninlined_format_args)]
</span><span class="boring">
</span><span class="boring">use calloop::EventLoop;
</span><span class="boring">
</span><span class="boring">// futures = &quot;0.3&quot;
</span><span class="boring">use futures::sink::SinkExt;
</span><span class="boring">use futures::stream::StreamExt;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; std::io::Result&lt;()&gt; {
</span><span class="boring">    let (exec, sched) = calloop::futures::executor()?;
</span><span class="boring">
</span>    let mut event_loop = EventLoop::try_new()?;
    let handle = event_loop.handle();

    handle
        .insert_source(exec, |evt, _metadata, _shared| {
            // Print the value of the async block ie. the return value.
            println!(&quot;Async block ended with: {}&quot;, evt);
        })
        .map_err(|e| e.error)?;
<span class="boring">
</span><span class="boring">    // Let's create two channels for our async blocks below. The blocks will
</span><span class="boring">    // exchange messages via these channels.
</span><span class="boring">    let (mut sender_friendly, mut receiver_friendly) = futures::channel::mpsc::unbounded();
</span><span class="boring">    let (mut sender_aloof, mut receiver_aloof) = futures::channel::mpsc::unbounded();
</span><span class="boring">
</span><span class="boring">    // Our toy async code.
</span><span class="boring">    let async_friendly_task = async move {
</span><span class="boring">        sender_friendly.send(&quot;Hello,&quot;).await.ok();
</span><span class="boring">        if let Some(msg) = receiver_aloof.next().await {
</span><span class="boring">            println!(&quot;Aloof said: {}&quot;, msg);
</span><span class="boring">        }
</span><span class="boring">        sender_friendly.send(&quot;world!&quot;).await.ok();
</span><span class="boring">        if let Some(msg) = receiver_aloof.next().await {
</span><span class="boring">            println!(&quot;Aloof said: {}&quot;, msg);
</span><span class="boring">        }
</span><span class="boring">        &quot;Bye!&quot;
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let async_aloof_task = async move {
</span><span class="boring">        if let Some(msg) = receiver_friendly.next().await {
</span><span class="boring">            println!(&quot;Friendly said: {}&quot;, msg);
</span><span class="boring">        }
</span><span class="boring">        sender_aloof.send(&quot;Oh,&quot;).await.ok();
</span><span class="boring">        if let Some(msg) = receiver_friendly.next().await {
</span><span class="boring">            println!(&quot;Friendly said: {}&quot;, msg);
</span><span class="boring">        }
</span><span class="boring">        sender_aloof.send(&quot;it's you.&quot;).await.ok();
</span><span class="boring">        &quot;Regards.&quot;
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    // Schedule the async block to be run in the event loop.
</span><span class="boring">    sched.schedule(async_friendly_task).unwrap();
</span><span class="boring">    sched.schedule(async_aloof_task).unwrap();
</span><span class="boring">
</span><span class="boring">    // Run the event loop.
</span><span class="boring">    println!(&quot;Starting event loop. Use Ctrl-C to exit.&quot;);
</span><span class="boring">    event_loop.run(None, &amp;mut (), |_| {})?;
</span><span class="boring">    println!(&quot;Event loop ended.&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>Now let's write our async code in full:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(clippy::uninlined_format_args)]
</span><span class="boring">
</span><span class="boring">use calloop::EventLoop;
</span><span class="boring">
</span><span class="boring">// futures = &quot;0.3&quot;
</span><span class="boring">use futures::sink::SinkExt;
</span><span class="boring">use futures::stream::StreamExt;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; std::io::Result&lt;()&gt; {
</span><span class="boring">    let (exec, sched) = calloop::futures::executor()?;
</span><span class="boring">
</span><span class="boring">    let mut event_loop = EventLoop::try_new()?;
</span><span class="boring">    let handle = event_loop.handle();
</span><span class="boring">
</span><span class="boring">    handle
</span><span class="boring">        .insert_source(exec, |evt, _metadata, _shared| {
</span><span class="boring">            // Print the value of the async block ie. the return value.
</span><span class="boring">            println!(&quot;Async block ended with: {}&quot;, evt);
</span><span class="boring">        })
</span><span class="boring">        .map_err(|e| e.error)?;
</span><span class="boring">
</span>    // Let's create two channels for our async blocks below. The blocks will
    // exchange messages via these channels.
    let (mut sender_friendly, mut receiver_friendly) = futures::channel::mpsc::unbounded();
    let (mut sender_aloof, mut receiver_aloof) = futures::channel::mpsc::unbounded();

    // Our toy async code.
    let async_friendly_task = async move {
        sender_friendly.send(&quot;Hello,&quot;).await.ok();
        if let Some(msg) = receiver_aloof.next().await {
            println!(&quot;Aloof said: {}&quot;, msg);
        }
        sender_friendly.send(&quot;world!&quot;).await.ok();
        if let Some(msg) = receiver_aloof.next().await {
            println!(&quot;Aloof said: {}&quot;, msg);
        }
        &quot;Bye!&quot;
    };

    let async_aloof_task = async move {
        if let Some(msg) = receiver_friendly.next().await {
            println!(&quot;Friendly said: {}&quot;, msg);
        }
        sender_aloof.send(&quot;Oh,&quot;).await.ok();
        if let Some(msg) = receiver_friendly.next().await {
            println!(&quot;Friendly said: {}&quot;, msg);
        }
        sender_aloof.send(&quot;it's you.&quot;).await.ok();
        &quot;Regards.&quot;
    };
<span class="boring">
</span><span class="boring">    // Schedule the async block to be run in the event loop.
</span><span class="boring">    sched.schedule(async_friendly_task).unwrap();
</span><span class="boring">    sched.schedule(async_aloof_task).unwrap();
</span><span class="boring">
</span><span class="boring">    // Run the event loop.
</span><span class="boring">    println!(&quot;Starting event loop. Use Ctrl-C to exit.&quot;);
</span><span class="boring">    event_loop.run(None, &amp;mut (), |_| {})?;
</span><span class="boring">    println!(&quot;Event loop ended.&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>Like any block in Rust, the value of your async block is the last expression ie. it is effectively &quot;returned&quot; from the block, which means it will be provided to your executor's callback as the first argument (the &quot;event&quot;). You'll see this in the output with the <code>Async block ended with: ...</code> lines.</p>
<p>Finally, we run the loop:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(clippy::uninlined_format_args)]
</span><span class="boring">
</span><span class="boring">use calloop::EventLoop;
</span><span class="boring">
</span><span class="boring">// futures = &quot;0.3&quot;
</span><span class="boring">use futures::sink::SinkExt;
</span><span class="boring">use futures::stream::StreamExt;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; std::io::Result&lt;()&gt; {
</span><span class="boring">    let (exec, sched) = calloop::futures::executor()?;
</span><span class="boring">
</span><span class="boring">    let mut event_loop = EventLoop::try_new()?;
</span><span class="boring">    let handle = event_loop.handle();
</span><span class="boring">
</span><span class="boring">    handle
</span><span class="boring">        .insert_source(exec, |evt, _metadata, _shared| {
</span><span class="boring">            // Print the value of the async block ie. the return value.
</span><span class="boring">            println!(&quot;Async block ended with: {}&quot;, evt);
</span><span class="boring">        })
</span><span class="boring">        .map_err(|e| e.error)?;
</span><span class="boring">
</span><span class="boring">    // Let's create two channels for our async blocks below. The blocks will
</span><span class="boring">    // exchange messages via these channels.
</span><span class="boring">    let (mut sender_friendly, mut receiver_friendly) = futures::channel::mpsc::unbounded();
</span><span class="boring">    let (mut sender_aloof, mut receiver_aloof) = futures::channel::mpsc::unbounded();
</span><span class="boring">
</span><span class="boring">    // Our toy async code.
</span><span class="boring">    let async_friendly_task = async move {
</span><span class="boring">        sender_friendly.send(&quot;Hello,&quot;).await.ok();
</span><span class="boring">        if let Some(msg) = receiver_aloof.next().await {
</span><span class="boring">            println!(&quot;Aloof said: {}&quot;, msg);
</span><span class="boring">        }
</span><span class="boring">        sender_friendly.send(&quot;world!&quot;).await.ok();
</span><span class="boring">        if let Some(msg) = receiver_aloof.next().await {
</span><span class="boring">            println!(&quot;Aloof said: {}&quot;, msg);
</span><span class="boring">        }
</span><span class="boring">        &quot;Bye!&quot;
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let async_aloof_task = async move {
</span><span class="boring">        if let Some(msg) = receiver_friendly.next().await {
</span><span class="boring">            println!(&quot;Friendly said: {}&quot;, msg);
</span><span class="boring">        }
</span><span class="boring">        sender_aloof.send(&quot;Oh,&quot;).await.ok();
</span><span class="boring">        if let Some(msg) = receiver_friendly.next().await {
</span><span class="boring">            println!(&quot;Friendly said: {}&quot;, msg);
</span><span class="boring">        }
</span><span class="boring">        sender_aloof.send(&quot;it's you.&quot;).await.ok();
</span><span class="boring">        &quot;Regards.&quot;
</span><span class="boring">    };
</span><span class="boring">
</span>    // Schedule the async block to be run in the event loop.
    sched.schedule(async_friendly_task).unwrap();
    sched.schedule(async_aloof_task).unwrap();

    // Run the event loop.
    println!(&quot;Starting event loop. Use Ctrl-C to exit.&quot;);
    event_loop.run(None, &amp;mut (), |_| {})?;
    println!(&quot;Event loop ended.&quot;);
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<p>And our output looks like:</p>
<pre><code class="language-text">Starting event loop.
Friendly said: Hello,
Aloof said: Oh,
Friendly said: world!
Async block ended with: Regards.
Aloof said: it's you.
Async block ended with: Bye!
Event loop ended.
</code></pre>
<p>Note that for the sake of keeping this example short, I've written the async code before running the loop. But async code can be scheduled from callbacks, or other sources within the loop too.</p>
<blockquote>
<h2 id="note-about-threads"><a class="header" href="#note-about-threads">Note about threads</a></h2>
<p>One of Calloop's strengths is that it is completely single threaded as written. However, many async crates are implemented using threads eg. <code>async-std</code> and <code>async-process</code>. This is not an inherent problem! Calloop will work perfectly well with such implementations in general. However, if you have selected Calloop because of your own constraints around threading, be aware of this.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch03-00-async-await.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch03-02-async-io-types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch03-00-async-await.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch03-02-async-io-types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
