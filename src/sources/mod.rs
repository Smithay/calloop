use std::{
    cell::{Ref, RefCell, RefMut},
    io,
    rc::Rc,
};

use crate::{Poll, Readiness, Token};

pub mod channel;
pub mod generic;
pub mod ping;
#[cfg(target_os = "linux")]
pub mod signals;
pub mod timer;

/// Trait representing an event source
///
/// This is the trait you need to implement if you wish to create your own
/// calloop-compatible event sources.
///
/// The 3 type parameter define the type of closure the user will need to
/// provide to process events for your event source.
///
/// The `process_events` method will be called when one of the FD you registered
/// is ready, with the associated readiness and token.
///
/// The last 3 methods are plumbing to let your source register itself with the
/// polling system. See their documentation for details.
pub trait EventSource {
    /// The type of events generated by your source.
    type Event;
    /// Some metadata of your event source
    ///
    /// This is typically useful if your source contains some internal state that
    /// the user may need to interact with when processing events. The user callback
    /// will receive a `&mut Metadata` reference.
    ///
    /// Just set to `()` if not needed.
    type Metadata;
    /// The return type of the user callback
    ///
    /// If the user needs to return some value back to your event source once its
    /// processing is finshed (to indicate success or failure for example), you can
    /// specify it using this type.
    ///
    /// Just set to `()` if not needed.
    type Ret;

    /// Process any relevant events
    ///
    /// This method will be called every time one of the FD you registered becomes
    /// ready, including the readiness details and the associated token.
    ///
    /// Your event source will then do some processing of the file descriptor(s) to generate
    /// events, and call the provided `callback` for each one of them.
    ///
    /// You should ensure you drained the file descriptors of their events, especially if using
    /// edge-triggered mode.
    fn process_events<F>(
        &mut self,
        readiness: Readiness,
        token: Token,
        callback: F,
    ) -> std::io::Result<()>
    where
        F: FnMut(Self::Event, &mut Self::Metadata) -> Self::Ret;

    /// Register yourself to this poll instance
    ///
    /// You should register all your relevant file descriptors to the provided `Poll`
    /// using its `Poll::register` method.
    ///
    /// If you need to register more than one file descriptor, you can change the
    /// `sub_id` field of the `Token` to differentiate between them.
    fn register(&mut self, poll: &mut Poll, token: Token) -> io::Result<()>;

    /// Re-register your file descriptors
    ///
    /// Your should update the registration of all your relevant file descriptor to
    /// the provided `Poll` using its `Poll::reregister`, if necessary.
    fn reregister(&mut self, poll: &mut Poll, token: Token) -> io::Result<()>;

    /// Unregister your file descriptors
    ///
    /// You should unregister all your file descriptors from this `Poll` using its
    /// `Poll::unregister` method.
    fn unregister(&mut self, poll: &mut Poll) -> io::Result<()>;
}

pub(crate) struct DispatcherInner<S, F> {
    source: S,
    callback: F,
}

impl<Data, S, F> EventDispatcher<Data> for RefCell<DispatcherInner<S, F>>
where
    S: EventSource,
    F: FnMut(S::Event, &mut S::Metadata, &mut Data) -> S::Ret,
{
    fn process_events(
        &self,
        readiness: Readiness,
        token: Token,
        data: &mut Data,
    ) -> std::io::Result<()> {
        let mut disp = self.borrow_mut();
        let DispatcherInner {
            ref mut source,
            ref mut callback,
            ..
        } = *disp;
        source.process_events(readiness, token, |event, meta| callback(event, meta, data))
    }

    fn register(&self, poll: &mut Poll, token: Token) -> io::Result<()> {
        self.borrow_mut().source.register(poll, token)
    }

    fn reregister(&self, poll: &mut Poll, token: Token) -> io::Result<()> {
        self.borrow_mut().source.reregister(poll, token)
    }

    fn unregister(&self, poll: &mut Poll) -> io::Result<()> {
        self.borrow_mut().source.unregister(poll)
    }
}

pub(crate) trait EventDispatcher<Data> {
    fn process_events(
        &self,
        readiness: Readiness,
        token: Token,
        data: &mut Data,
    ) -> std::io::Result<()>;

    fn register(&self, poll: &mut Poll, token: Token) -> io::Result<()>;

    fn reregister(&self, poll: &mut Poll, token: Token) -> io::Result<()>;

    fn unregister(&self, poll: &mut Poll) -> io::Result<()>;
}

/// An event source with its callback.
///
/// The `Dispatcher` can be registered in an event loop.
/// Use the `as_source_{ref,mut}` functions to interact with the event source.
/// Use `into_source_inner` to get the event source back.
pub struct Dispatcher<S, F>(Rc<RefCell<DispatcherInner<S, F>>>);

impl<S, F> Dispatcher<S, F>
where
    S: EventSource,
{
    /// Builds a dispatcher.
    ///
    /// The resulting `Dispatcher`
    pub fn new<Data>(source: S, callback: F) -> Self
    where
        F: FnMut(S::Event, &mut S::Metadata, &mut Data) -> S::Ret,
    {
        Dispatcher(Rc::new(RefCell::new(DispatcherInner { source, callback })))
    }

    /// Returns an immutable reference to the event source.
    pub fn as_source_ref(&self) -> Ref<S> {
        Ref::map(self.0.borrow(), |inner| &inner.source)
    }

    /// Returns a mutable reference to the event source.
    pub fn as_source_mut(&mut self) -> RefMut<S> {
        RefMut::map(self.0.borrow_mut(), |inner| &mut inner.source)
    }

    /// Consumes the Dispatcher and returns the inner event source.
    ///
    /// # Panics
    ///
    /// Panics if the `Dispatcher` is still registered.
    pub fn into_source_inner(self) -> S {
        if let Ok(ref_cell) = Rc::try_unwrap(self.0) {
            ref_cell.into_inner().source
        } else {
            panic!("Dispatcher is still registered");
        }
    }

    pub(crate) fn clone_as_event_dispatcher<'a, Data>(&self) -> Rc<dyn EventDispatcher<Data> + 'a>
    where
        S: 'a,
        F: FnMut(S::Event, &mut S::Metadata, &mut Data) -> S::Ret + 'a,
    {
        Rc::clone(&self.0) as Rc<dyn EventDispatcher<Data> + 'a>
    }
}

impl<S, F> Clone for Dispatcher<S, F> {
    fn clone(&self) -> Dispatcher<S, F> {
        Dispatcher(Rc::clone(&self.0))
    }
}

/// An idle callback that was inserted in this loop
///
/// This handle allows you to cancel the callback. Dropping
/// it will *not* cancel it.
pub struct Idle<'i> {
    pub(crate) callback: Rc<RefCell<dyn CancellableIdle + 'i>>,
}

impl<'i> Idle<'i> {
    /// Cancel the idle callback if it was not already run
    pub fn cancel(self) {
        self.callback.borrow_mut().cancel();
    }
}

pub(crate) trait CancellableIdle {
    fn cancel(&mut self);
}

impl<F> CancellableIdle for Option<F> {
    fn cancel(&mut self) {
        self.take();
    }
}

pub(crate) trait IdleDispatcher<Data> {
    fn dispatch(&mut self, data: &mut Data);
}

impl<Data, F> IdleDispatcher<Data> for Option<F>
where
    F: FnMut(&mut Data),
{
    fn dispatch(&mut self, data: &mut Data) {
        if let Some(callabck) = self.as_mut() {
            callabck(data);
        }
    }
}
