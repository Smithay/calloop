//! Error types used and generated by Calloop.
//!
//! This module contains error types for working with Calloop. They are designed
//! to make it easy to deal with errors arising from Calloop's internal I/O
//! operations alongside errors generated by event sources and callbacks.
//!
//! There are two top-level error types:
//!
//! - [`Error`]: used by callback functions, internal operations, and some event
//!   loop API calls
//!
//! - [`InsertError`]: used primarily by the
//!   [`calloop::LoopHandle::insert_source()`] method when an event source
//!   cannot be added to the loop and needs to be given back to the caller
//!
//! If you are writing an event source (and specifically the
//! [`calloop::EventSource::process_events()`] function of an event source) you
//! should be able to simply use the `?` operator or return an error converted
//! with [`std::convert::Into::into()`]. Those should work seamlessly if your
//! error is a [`std::io::Error`] or if it implements `std::error::Error
//! + Sync + Send`.
//!
//! You might need to return an error which implements [`std::error::Error`] but
//! *not* `Sync + Send`, which is often the case for errors that "give back" a
//! value. In that case you can sacrifice your traceback structure and wrap your
//! error in [`CallbackErrorNonSync`] eg. with `.map_err(CallbackErrorNonSync)`.
//! This will render the error as a string.

use std::fmt::{self, Debug, Formatter};

/// The primary error type used by Calloop.
#[derive(thiserror::Error, Debug)]
pub enum Error {
    /// When an event source is registered (or re- or un-registered) with the
    /// event loop, this error variant will occur if the token Calloop uses to
    /// keep track of the event source is not valid.
    #[error("invalid token provided to internal function")]
    InvalidToken,

    /// This variant wraps a [`std::io::Error`], which might arise from
    /// Calloop's internal operations or within a user-defined callback or event
    /// source.
    #[error("underlying IO error")]
    IoError(#[from] std::io::Error),

    /// This variant wraps anything that can be converted into a boxed error ie.
    /// `Box<dyn std::error::Error + Sync + Send>` (which includes a plain old
    /// [`String`]). You should aim to use this for all non-I/O-related errors
    /// arising inside composed sources and callbacks. It should happen
    /// automatically if you use the `?` operator or the standard
    /// [`std::convert::Into::into()`] method.
    #[error("error generated by event callback")]
    CallbackError(#[from] Box<dyn std::error::Error + Sync + Send>),
}

impl From<nix::errno::Errno> for Error {
    fn from(err: nix::errno::Errno) -> Self {
        Into::<std::io::Error>::into(err).into()
    }
}

impl From<Error> for std::io::Error {
    fn from(err: Error) -> Self {
        match err {
            Error::IoError(source) => Self::new(source.kind(), source),
            Error::InvalidToken => Self::new(std::io::ErrorKind::InvalidInput, err),
            Error::CallbackError(src) => Self::new(std::io::ErrorKind::Other, src),
        }
    }
}

pub type Result<T> = core::result::Result<T, Error>;

#[derive(thiserror::Error, Debug)]
#[error("non-thread-safe error generated by event callback")]
pub struct CallbackErrorNonSync<E: std::error::Error + 'static>(#[from] E);

impl<E: std::error::Error> From<CallbackErrorNonSync<E>> for Error {
    fn from(error: CallbackErrorNonSync<E>) -> Self {
        Self::CallbackError(error.0.to_string().into())
    }
}

/// An error generated when trying to insert an event source
#[derive(thiserror::Error)]
#[error("error inserting event source")]
pub struct InsertError<T> {
    /// The source that could not be inserted
    pub inserted: T,
    /// The generated error
    #[source]
    pub error: Error,
}

#[cfg(not(tarpaulin_include))]
impl<E> Debug for InsertError<E> {
    fn fmt(&self, formatter: &mut Formatter) -> core::result::Result<(), fmt::Error> {
        write!(formatter, "{:?}", self.error)
    }
}

#[cfg(not(tarpaulin_include))]
impl<E> From<InsertError<E>> for crate::Error {
    fn from(e: InsertError<E>) -> crate::Error {
        e.error
    }
}
